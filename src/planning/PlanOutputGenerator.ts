/**
 * Plan Output Generator
 *
 * Generates structured Implementation Plan markdown from a planning session.
 * This is the final output after completing the 4-phase planning flow.
 */

import { Plan, PlanPhase, PlanStep, PlanningSession, PlanImpact } from './types';

/**
 * Implementation plan markdown template
 */
function generateImplementationPlanMarkdown(
  session: PlanningSession,
  plan?: Plan
): string {
  const timestamp = new Date().toISOString().split('T')[0];

  let markdown = `# Implementation Plan: ${session.feature}

**Created**: ${timestamp}
**Status**: ${session.status === 'completed' ? 'Approved' : 'Draft'}

---

## Summary

${session.description || `Implementation plan for ${session.feature}.`}

---

## Planning Session

### Study Phase
${formatPhaseNotes(session.phases.study.notes)}

### Connect Phase
${formatPhaseNotes(session.phases.connect.notes)}

### Plan Phase
${formatPhaseNotes(session.phases.plan.notes)}

### Review Phase
${formatPhaseNotes(session.phases.review.notes)}

---

## Affected Files

${formatAffectedFiles(session.affectedFiles)}

---

## Risk Assessment

**Overall Risk Level**: ${session.riskAssessment.overall.toUpperCase()}

${formatRiskItems(session.riskAssessment.items)}

---
`;

  // If we have a generated plan, include its phases
  if (plan) {
    markdown += `
## Implementation Phases

${formatPlanPhases(plan.phases)}

---

## Impact Analysis

${formatImpact(plan.impact)}

---
`;
  }

  // Add approval section
  markdown += `
## Approval

- [ ] Plan reviewed by Claude (Creator)
- [ ] Code mapping verified by Gears (Engineer)
- [ ] Documentation updated by Index (Librarian)
- [ ] User approval obtained

---

## Notes

${session.gddContext ? `### GDD Context\n${session.gddContext}\n\n` : ''}
${session.saContext ? `### SA Context\n${session.saContext}\n\n` : ''}

---

*Generated by SpaceCode Planning System*
`;

  return markdown;
}

/**
 * Format phase notes
 */
function formatPhaseNotes(notes: string[]): string {
  if (!notes || notes.length === 0) {
    return '*No notes recorded.*';
  }

  return notes.map(note => `- ${note}`).join('\n');
}

/**
 * Format affected files list
 */
function formatAffectedFiles(
  files: Array<{ path: string; action: string; discoveredInPhase?: string }>
): string {
  if (!files || files.length === 0) {
    return '*No files identified yet.*';
  }

  // Group by action
  const creates = files.filter(f => f.action === 'create');
  const modifies = files.filter(f => f.action === 'modify');
  const deletes = files.filter(f => f.action === 'delete');

  let output = '';

  if (creates.length > 0) {
    output += '### New Files\n';
    output += creates.map(f => `- \`${f.path}\``).join('\n');
    output += '\n\n';
  }

  if (modifies.length > 0) {
    output += '### Modified Files\n';
    output += modifies.map(f => `- \`${f.path}\``).join('\n');
    output += '\n\n';
  }

  if (deletes.length > 0) {
    output += '### Deleted Files\n';
    output += deletes.map(f => `- \`${f.path}\``).join('\n');
    output += '\n\n';
  }

  return output || '*No files identified yet.*';
}

/**
 * Format risk items
 */
function formatRiskItems(
  items: Array<{ level: string; description: string; mitigation?: string }>
): string {
  if (!items || items.length === 0) {
    return '*No risks identified.*';
  }

  return items.map(item => {
    let emoji = '‚ö™';
    if (item.level === 'low') emoji = 'üü¢';
    else if (item.level === 'medium') emoji = 'üü°';
    else if (item.level === 'high') emoji = 'üü†';
    else if (item.level === 'critical') emoji = 'üî¥';

    let text = `${emoji} **${item.level.toUpperCase()}**: ${item.description}`;
    if (item.mitigation) {
      text += `\n  - *Mitigation*: ${item.mitigation}`;
    }
    return text;
  }).join('\n\n');
}

/**
 * Format plan phases
 */
function formatPlanPhases(phases: PlanPhase[]): string {
  if (!phases || phases.length === 0) {
    return '*No phases defined.*';
  }

  return phases.map((phase, index) => {
    let output = `### Phase ${index + 1}: ${phase.title}\n\n`;
    output += `${phase.description}\n\n`;

    if (phase.steps && phase.steps.length > 0) {
      output += phase.steps.map(step => formatStep(step)).join('\n');
    }

    if (phase.dependsOn && phase.dependsOn.length > 0) {
      output += `\n**Depends on**: ${phase.dependsOn.join(', ')}\n`;
    }

    return output;
  }).join('\n---\n\n');
}

/**
 * Format a single step
 */
function formatStep(step: PlanStep): string {
  const statusEmoji = step.status === 'done' ? '‚úÖ' : '‚¨ú';
  const priorityBadge = step.priority === 'critical' ? 'üî¥' :
    step.priority === 'high' ? 'üü†' :
    step.priority === 'medium' ? 'üü°' : 'üü¢';

  let output = `- ${statusEmoji} ${step.description}\n`;
  output += `  - ${priorityBadge} Priority: ${step.priority}\n`;
  output += `  - Change type: ${step.changeType}\n`;

  if (step.files && step.files.length > 0) {
    output += `  - Files: ${step.files.map(f => `\`${f}\``).join(', ')}\n`;
  }

  if (step.rationale) {
    output += `  - *Rationale*: ${step.rationale}\n`;
  }

  return output;
}

/**
 * Format impact analysis
 */
function formatImpact(impact: PlanImpact): string {
  let output = '';

  output += `**Risk Level**: ${impact.riskLevel.toUpperCase()}\n\n`;

  if (impact.sectorsAffected && impact.sectorsAffected.length > 0) {
    output += `**Sectors Affected**: ${impact.sectorsAffected.join(', ')}\n\n`;
  }

  if (impact.dependenciesAffected && impact.dependenciesAffected.length > 0) {
    output += `**Dependencies Affected**: ${impact.dependenciesAffected.join(', ')}\n\n`;
  }

  if (impact.warnings && impact.warnings.length > 0) {
    output += '**Warnings**:\n';
    output += impact.warnings.map(w => `- ‚ö†Ô∏è ${w}`).join('\n');
    output += '\n\n';
  }

  return output || '*No impact analysis available.*';
}

/**
 * Plan Output Generator class
 */
export class PlanOutputGenerator {
  /**
   * Generate markdown implementation plan from session
   */
  generateMarkdown(session: PlanningSession, plan?: Plan): string {
    return generateImplementationPlanMarkdown(session, plan);
  }

  /**
   * Generate JSON export of the plan
   */
  generateJson(session: PlanningSession, plan?: Plan): string {
    return JSON.stringify({
      session: {
        id: session.id,
        feature: session.feature,
        description: session.description,
        status: session.status,
        currentPhase: session.currentPhase,
        createdAt: new Date(session.createdAt).toISOString(),
        updatedAt: new Date(session.updatedAt).toISOString(),
        affectedFiles: session.affectedFiles,
        riskAssessment: session.riskAssessment,
        phases: {
          study: { notes: session.phases.study.notes, status: session.phases.study.status },
          connect: { notes: session.phases.connect.notes, status: session.phases.connect.status },
          plan: { notes: session.phases.plan.notes, status: session.phases.plan.status },
          review: { notes: session.phases.review.notes, status: session.phases.review.status }
        }
      },
      implementationPlan: plan ? {
        id: plan.id,
        intent: plan.intent,
        summary: plan.summary,
        phases: plan.phases,
        impact: plan.impact,
        totalSteps: plan.totalSteps,
        completedSteps: plan.completedSteps
      } : null
    }, null, 2);
  }

  /**
   * Generate a simple summary for chat/display
   */
  generateSummary(session: PlanningSession): string {
    const fileCount = session.affectedFiles.length;
    const riskLevel = session.riskAssessment.overall;

    return `üìã **Implementation Plan: ${session.feature}**

- **Status**: ${session.status}
- **Files affected**: ${fileCount}
- **Risk level**: ${riskLevel.toUpperCase()}
- **Phases completed**: ${countCompletedPhases(session)}

${session.description || ''}`.trim();
  }
}

/**
 * Count completed phases
 */
function countCompletedPhases(session: PlanningSession): string {
  const phases = ['study', 'connect', 'plan', 'review'] as const;
  let completed = 0;

  for (const phase of phases) {
    if (session.phases[phase].status === 'completed' ||
        session.phases[phase].status === 'skipped') {
      completed++;
    }
  }

  return `${completed}/4`;
}

/**
 * Export singleton instance
 */
let _planOutputGenerator: PlanOutputGenerator | null = null;

export function getPlanOutputGenerator(): PlanOutputGenerator {
  if (!_planOutputGenerator) {
    _planOutputGenerator = new PlanOutputGenerator();
  }
  return _planOutputGenerator;
}
